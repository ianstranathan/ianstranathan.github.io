<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <!-- CSS -->
    <link rel="stylesheet" href="../../style/style.css">
    
    <!-- Katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
              // customised options
              // • auto-render specific keys, e.g.:
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              // • rendering keys, e.g.:
              throwOnError : false
            });
        });
    </script>
    <!-- highlightjs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script defer>hljs.highlightAll();</script>
    <!-- Google Font -->  
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cousine&display=swap" rel="stylesheet"> 
    <!-- FontAwesome -->
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- My own stuff -->
    <!-- ---------------------------------------------------------------  -->
    <script src="../../scripts/metaStuff.js"></script>
    <script src="../../scripts/header.js" defer></script>
    <script src="../../scripts/about.js" defer></script>
    <!-- Injects table of contents at beginning of each content div -->
    <script src="../../scripts/makeTableOfContents.js" defer></script>
    <!-- Injects page with static pages from metadata -->
    <script src="../../scripts/linkInjection.js" defer></script>
    <script src="../../scripts/latexWorkAround.js" defer></script>
    <script src="../../scripts/footer.js" defer></script>
  
    <!-- ---------------------------------------------------------------  -->
  </head>

  <body>
   
    <div id="header">
    </div>
    
    <div id="content-categories-container">
      
      <div id="content"><p><em>While working through Peter Shirley's <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">"Raytracing in One Weekend"</a>
I had trouble justifying the handwaved expression for a refracted ray and had to derive it for myself</em></p>
<h1 id="overview">Overview</h1>
<p>Computer graphics uses geometrical optics as its light propogation model.</p>
<p>From the Wikipedia for <a href="https://en.wikipedia.org/wiki/Geometrical_optics">geometrical optics</a> :</p>
<p>"Geometrical optics, or ray optics, is a model of optics that describes light propagation in terms of rays.</p>
<p>…
rays:</p>
<ul>
<li>Propagate in straight-line paths as they travel in a homogeneous medium.</li>
<li>Bend, and in particular circumstances may split in two, at the interface between two dissimilar media.</li>
<li>Follow curved paths in a medium in which the refractive index changes.</li>
<li>May be absorbed or reflected."</li>
</ul>
<p>This is the model used because it cheaply and understandbly accounts for most phenonmena.
(This will fail to account for diffraction and interference properties of light (wave properties) -- for example: thin film light interference in soap bubbles, light bending around a small aperture like a closed door etc)</p>
<p>The raytacing implementation (Whitted) is based on recursively shooting more rays from each ray-object intersection point up to some recursion limit.
Note that ray tracing, if it is limited to just the recursive algorithm, is not necessarily realistic as it does not satisfy the rendering equation (the bundled underlying physics, conservation laws).</p>
<p>Using the ray model forces us to account for refraction and reflection (Fresnel equations, total internal reflection, and Beer’s Law as well…)</p>
<h1 id="reflection">Reflection</h1>
<p>I think Shirley's derivation is good with just some small (probably obvious depending on your trust and intuition of the dot product) details ommited and his drawing works well too:</p>
<!-- ![<code class='latexWorkaround'>$\hat n$</code> , the normal, and <code class='latexWorkaround'>$\vec v$</code>, the incident ray, from [Shirley](https://raytracing.github.io/books/RayTracingInOneWeekend.html#metal/mirroredlightreflection)](../images/reflectionAndRefraction/shirleyReflection.png) -->
<div id="center">
    <img src="../../images/reflectionAndRefraction/shirleyReflection.png">
    <p><code class='latexWorkaround'>$\hat n$</code> , the normal, and <code class='latexWorkaround'>$\vec v$</code>, the incident ray, from <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html#metal/mirroredlightreflection"></a></p>
</div>
<p>The dot product for the two vectors is by definition:
<code class='latexWorkaround'>$
\vec v \cdot \hat n = \lvert \lvert \vec v \rvert \rvert \lvert \lvert \hat n \rvert \rvert \cos {\theta}
$</code>
Where <code class='latexWorkaround'>$\theta$</code> is the angle between each vector, tail to tail.</p>
<p>Since the length of a unit vector is <code class='latexWorkaround'>$1$</code>, <code class='latexWorkaround'>$\lvert \lvert \hat n \rvert \rvert = 1$</code>
<code class='latexWorkaround'>$
\vec v \cdot \hat n = \lvert \lvert \vec v \rvert \rvert \cos {\theta}
$</code></p>
<p>If you're comfortable with the dot product as a projection operator, then clearly 
the magnitude <code class='latexWorkaround'>$B$</code> is just <code class='latexWorkaround'>$\vec v \cdot \hat n$</code>.
If you're distrustful due to the obtuse angle between them, reverse the direction of the incident ray <code class='latexWorkaround'>$= -\vec v$</code>, 
now the <code class='latexWorkaround'>$\lvert \lvert \vec v \rvert \rvert \cos {\theta}$</code> is clearly just the trigonometric leg along the normal.</p>
<!-- Alternatively, you could use the obtuse angle and use the fact that sine and cosine are equal after a half pi phase shift
, <code class='latexWorkaround'>$\sin \left( {x + \frac{\pi}{2}} \right)= \cos x$</code>.<br>
Trigonometrically, <code class='latexWorkaround'>$B$</code> is just the opposite leg of the angle <code class='latexWorkaround'>$\phi$</code> s.t. <code class='latexWorkaround'>$\phi = \theta - \frac{\pi}{2}$</code>,
<code class='latexWorkaround'>$B = \lvert \lvert \vec v \rvert \rvert \sin \phi = \lvert \lvert \vec v \rvert \rvert \cos \left( \phi - \frac{\pi}{2} \right)$</code> -->
<!-- <code class='latexWorkaround'>$\vec v \cdot \hat n = \lvert \lvert \vec v \rvert \rvert \cos {\theta}$</code> -->
<!-- Since the incident ray and the normal are obtuse to each other, the magnitude <code class='latexWorkaround'>${\lvert \lvert \vec B \rvert \rvert}$</code> must equal
<code class='latexWorkaround'>$-\vec v \cdot \hat n$</code><br> -->
<p>Finding the reflected vector is now just a matter of using vector addition:</p>
<p><code class='latexWorkaround'>$\vec v + 2\vec B = {\vec v}_{refl}$</code>
<code class='latexWorkaround'>${\vec v}_{refl} = \vec v - 2\left(\vec v \cdot \hat n \right)$</code></p>
<p>Another good, alternative derivation for the reflected vector, in this case for specular lighting in rasterization can be found <a href="http://learnwebgl.brown37.net/09_lights/lights_specular.html">here</a></p>
<h1 id="refraction">Refraction</h1>
<!-- ![Diagram from <a href="https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf">Bram De Greve</a>](../images/reflectionAndRefraction\bramDeGreve.png) -->
<div id="center">
    <img src="../../images/reflectionAndRefraction/bramDeGreve.png">
    <p>Diagram from <a href="https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf">Bram De Greve</a></p>
</div>
<p>Available tools in the toolkit: Snell's law, vector math, trigonometry</p>
<ol>
<li>[Snell's law](snell's law link), see derivation <a href="mylink">here</a>: </li>
</ol>
<p><code class='latexWorkaround'>${\eta}_1 \sin {\theta}_i = {\eta}_2 \sin {\theta}_t$</code></p>
<ol start="2">
<li>Vector expression for the incident and refracted rays:</li>
</ol>
<p><code class='latexWorkaround'>$ \vec i = {\vec i }_{||} + {\vec i}_{⊥}$</code>
<code class='latexWorkaround'>$ \vec t = {\vec t }_{||} + {\vec t}_{⊥}$</code></p>
<ol start="3">
<li>Expression for the sine of the incident and refracted angles:</li>
</ol>
<p><code class='latexWorkaround'>$\sin {\theta}_i = \frac {\lvert \lvert {\vec i }_{||} \rvert \rvert}{\lvert \lvert \vec i \rvert \rvert}$</code>
<code class='latexWorkaround'>$\sin {\theta}_t = \frac {\lvert \lvert {\vec t }_{||} \rvert \rvert}{\lvert \lvert \vec t \rvert \rvert}$</code></p>
<ol start="4">
<li>Euclidean metric (pythagorean theorem)</li>
</ol>
<p><code class='latexWorkaround'>${\lvert \lvert \vec i \rvert \rvert}^2 = {\lvert \lvert {\vec i }_{||} \rvert \rvert}^2 + {\lvert \lvert {\vec i }_{⊥} \rvert \rvert}^2$</code>
<code class='latexWorkaround'>${\lvert \lvert \vec t \rvert \rvert}^2 = {\lvert \lvert {\vec t }_{||} \rvert \rvert}^2 + {\lvert \lvert {\vec t }_{⊥} \rvert \rvert}^2$</code></p>
<p>Solving for its components:</p>
<p>By  3:
<code class='latexWorkaround'>$\lvert \lvert {\vec t }_{||} \rvert \rvert = \lvert \lvert \vec t \rvert \rvert \sin {\theta}_t   $</code></p>
<p>By  1:
<code class='latexWorkaround'>$\lvert \lvert {\vec t }_{||} \rvert \rvert = \lvert \lvert \vec t \rvert \rvert \frac{{\eta}_1}{{\eta}_2} \sin {\theta}_i$</code></p>
<p>By  3.
<code class='latexWorkaround'>$= \lvert \lvert \vec t \rvert \rvert \frac{{\eta}_1}{{\eta}_2} \frac {\lvert \lvert {\vec i }_{||} \rvert \rvert}{\lvert \lvert \vec i \rvert \rvert}$</code>
<code class='latexWorkaround'>$= \frac{\lvert \lvert \vec t \rvert \rvert}{\lvert \lvert \vec i \rvert \rvert} \frac{{\eta}_1}{{\eta}_2} \lvert \lvert {\vec i }_{||} \rvert \rvert $</code></p>
<p>Note:<br>
Even if the ray isn't normalized, for the simplfified geometric/ ray model, the incident and refracted ray
are the same ray, despite a change in orientation, and must accordingly have the same length.</p>
<p>This is obviously true for the reflected case, but I see no reason why this would be different for the refracted case.
(This was a small conceptual barrier for me as Shirley's raytracer does not normalize it's rays -- "Note that I do not make the ray direction a unit length vector because I think not doing that makes for simpler and slightly faster code."
and de Greve's does but they both yield the same expression)</p>
<p><code class='latexWorkaround'>$\implies \frac{\lvert \lvert \vec t \rvert \rvert}{\lvert \lvert \vec i \rvert \rvert} = 1$</code>
<code class='latexWorkaround'>$\lvert \lvert {\vec t }_{||} \rvert \rvert = \frac{{\eta}_1}{{\eta}_2} \lvert \lvert {\vec i }_{||} \rvert \rvert $</code></p>
<p>Since the parallel part of both the incident and refracted ray point in the same direction this expression is true in vector form as well.</p>
<p><code class='latexWorkaround'>${\vec t }_{||} = \frac{{\eta}_1}{{\eta}_2} {\vec i }_{||}$</code></p>
<p>By  2:</p>
<p><code class='latexWorkaround'>${\vec t }_{||} = \frac{{\eta}_1}{{\eta}_2} \left(  \vec i - {\vec i}_{⊥}    \right)$</code></p>
<p>We already know about the incident ray in our raytracer and the perpendicular component can be expressed 
by the dot product using the same reasoning from the reflection derivation:</p>
<p><code class='latexWorkaround'>${\vec i}_{⊥} = -\vec i \cdot \hat n = -\lvert \lvert \vec i \rvert \rvert \cos {\theta}_{i} \hat n $</code></p>
<p><code class='latexWorkaround'>${\vec t }_{||} = \frac{{\eta}_1}{{\eta}_2} \left(  \vec i + \lvert \lvert \vec i \rvert \rvert \cos {\theta}_{i} \hat n    \right)$</code></p>
<p>The parallel component gives us the perpendicular one directly from the pythagorean theorem.</p>
<p>By 4:
<code class='latexWorkaround'>${\lvert \lvert {\vec t }_{⊥} \rvert \rvert} = \sqrt{{\lvert \lvert \vec t \rvert \rvert}^2 - {\lvert \lvert {\vec t }_{||} \rvert \rvert}^2}$</code>
<code class='latexWorkaround'>$\implies$</code>
<code class='latexWorkaround'>${\vec t }_{⊥} = -\sqrt{{\lvert \lvert \vec t \rvert \rvert}^2 - {\lvert \lvert {\vec t }_{||} \rvert \rvert}^2} \hat n$</code></p>
<p>With both components expressed, it's again just a matter of vector addition for the resultant refracted vector.</p>
<p>While both component's expressions differ from Shirley's, they do so exactly by the non-normalized incident and refracted vector lengths and reduce to Shirley's expressions respectively if normalized. 
(It would seem that Shirley accidentally used the normalized expressions commonly found in the literature… 
I'm still very thankful for his free and very well written resource despite the small amount of hair pulling this induced)</p>
<h1 id="resources">Resources</h1>
<ul>
<li><a href="https://www.realtimerendering.com/Principles_of_Digital_Image_Synthesis_v1.0.1.pdf">Principles of Digital Image Synthesis</a> - Andrew Glassner (see 11.19)</li>
<li><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Raytracing in One Weekend</a> - Peter Shirley</li>
<li><a href="https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf">Reflections and Refractions in Ray Tracing</a> - Bram de Greve</li>
</ul>
<hr />
      </div>
      
      <div id="categories">
      </div>
      
    </div>
  
  </body>
<html>

