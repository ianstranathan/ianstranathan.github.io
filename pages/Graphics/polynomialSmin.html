<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="../../misc/miscImgs/hello.ico">
    <title>Ian Stranathan</title>
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <!-- CSS -->
    <link rel="stylesheet" href="../../style/style.css">
    
    <!-- Katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
              // customised options
              // • auto-render specific keys, e.g.:
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              // • rendering keys, e.g.:
              throwOnError : false
            });
        });
    </script>
    <!-- highlightjs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script defer>hljs.highlightAll();</script>
    <!-- Google Font -->  
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cousine&display=swap" rel="stylesheet"> 
    <!-- FontAwesome -->
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- My own stuff -->
    <!-- ---------------------------------------------------------------  -->
    <script src="../../scripts/metaStuff.js"></script>
    <script src="../../scripts/header.js" defer></script>
    <script src="../../scripts/about.js" defer></script>
    <!-- Injects table of contents at beginning of each content div -->
    <script src="../../scripts/makeTableOfContents.js" defer></script>
    <!-- Injects page with static pages from metadata -->
    <script src="../../scripts/linkInjection.js" defer></script>
    <script src="../../scripts/latexWorkAround.js" defer></script>
    <script src="../../scripts/footer.js" defer></script>
  
    <!-- ---------------------------------------------------------------  -->
  </head>

  <body>
   
    <div id="header">
    </div>
    
    <div id="content-categories-container">
      
      <div id="content"><p>TL;DR: Live shader <a href="../../demos/sminLive.html">here</a>.</p>
<p>Iñigo Quilez, hallowed be his name, wrote a function for blending distance function primitives to model organic shapes with raymarching.
(for introduction to raymarching, see the article I wrote <a href="raymarching.html">here</a>)
He wrote a very nice article about it <a href="https://www.iquilezles.org/www/articles/smin/smin.htm">here</a>.
It's a foundational technique to get natural looking implicit surfaces which is important because nature is smooth and continuous(… that's at least what they told me in school anyway) and a simple union of two shapes is not.</p>
<p>"The first time you see something it's a trick, the second time it's a technique" and for anyone that is trying to learn this stuff and for whom it's still a trick, hopefully this is helpful.
I know I can only reluctantly use some derived result if I don't understand where it's coming from.</p>
<p>It was impossible to follow iq's derivation in his article, surely the material is just so obvious to him that the terseness with which his derivation was written wasn't intentional.
In my opinion, especially for the beginner like me, derivations are not the place for compactness, especially for something so foundational. <br></p>
<p>It really gave me pause to see a couple really smart guys I follow using this function without fulling understanding it or deriving it correctly.
See: <a href="https://www.youtube.com/watch?v=Cp5WWtMoeKg&t=185s" target="_blank">Sebastian Lague</a> and
<a href="https://www.youtube.com/watch?v=YJ4iyff7zbk&t=453s" target="_blank">The Art of Code</a><br>
Both are far more productive, experienced and knowledgable than me, so maybe the real takeaway of this derivation is to choose my battles more wisely.
There is however something deeply fruitful about reinventing the wheel, despite the undeniable loss in productivity.</p>
<hr />
<p>Looking at iq's article, the example of the polynomial smin seems to be getting a smooth minimum between
some decreasing exponential and a sinusoid. That seems a little hard to think about right now with it's many intersection points to account for, so let's just look at a decreasing exponential with one intersection</p>
<div id="center">
    <img src="../../images/polynomialSmin/smin0.png">
    <p>Our functions; <code class='latexWorkaround'>$f(x) = x^2$</code> and  <code class='latexWorkaround'>$g(x) = e^{-x}$</code></p>
</div>
<div id="center">
    <img src="../../images/polynomialSmin/smin1.png">
    <p>The simple union of our two functions</p>
</div>
<p>Looking at this hard minimum, we can imagine a smooth curve in its place that connects <code class='latexWorkaround'>$f$</code> and <code class='latexWorkaround'>$g$</code>
when the functions are sufficiently close to their intersection.
But what does sufficiently close mean more precisely, <code class='latexWorkaround'>$i.e$</code> where should the constructed function stop being <code class='latexWorkaround'>$f$</code> and start being <code class='latexWorkaround'>$g$</code>?</p>
<div id="center">
    <img src="../../images/polynomialSmin/smin1.png">
    <p>Our functions with their difference <code class='latexWorkaround'>$d = f(x) - g(x)$</code></p>
</div>
<p>Now for a reasonably useless aside:</p>
<p>At first blush, it's not obvious to me how to make a meaningful relationship or constraint between the two functions
beyond that they're equal to each other at their intersection. This gives us a point <code class='latexWorkaround'>$C$</code>, <code class='latexWorkaround'>$d = 0$</code> and its mapping <code class='latexWorkaround'>$x$</code>-value</p>
<p>Looking at a given &nbsp;<code class='latexWorkaround'>$ε$</code> &nbsp;neighborhood around this point, you can see that <code class='latexWorkaround'>$d$</code> must be on the interval <code class='latexWorkaround'>$[d(x-ε), d(x+ε)]$</code>
which are small, not necessarily identical values.</p>
<div id="center">
    <img src="../../images/polynomialSmin/sminEpsilon.png">
</div>
<p>Well, now we're at loss about how to generalize along this line of thinking.</p>
<p>And it gets worse, talking about points close to where a root of a function is requires us to know where the root is in the first place. This is a non trivial thing and a whole numerical method in its own right.
And even worse… iq's original diagram was of some flavor of a sinusoid and its intersection with a decreasing exponential has infinitely many roots. <br>
We're noping on out of here my friend, it's just too messy; we'll need to think of another relationship characteristic of proximity to the intersection.</p>
<p>A helpful observation is to note that this <code class='latexWorkaround'>$ε$</code> could be made arbitrarily small, small enough to where
<code class='latexWorkaround'>$[d(x-ε), d(x+ε)]$</code>
is smaller than our original epsilon.</p>
<div id="center">
    <img src="../../images/polynomialSmin/sminEpsilon2.png">
</div>
<p>It's also helpful to note that the difference between two polynomials is also a polynomial and that polynomials are continuous everywhere.
So, by the intermediate value theorem, for some small value say <code class='latexWorkaround'>$k$</code>, <code class='latexWorkaround'>$d∈ [-k, k]$</code>.</p>
<p>"Sufficiently close" to an intersection then could be recast in terms of the difference's value instead of being near its root.</p>
<p>Note however that <code class='latexWorkaround'>$d$</code> reaches <code class='latexWorkaround'>$-k$</code> and <code class='latexWorkaround'>$k$</code> at different rates, however slightly different, as discussed previously and if we are planning on using this interval as our generalized way to talk about being close to the intersection
our choice of <code class='latexWorkaround'>$k$</code> will affect how the curve stiches to its base functions.
In the limit close to <code class='latexWorkaround'>$C$</code> this doesnt matter, but for medium sized choices of <code class='latexWorkaround'>$k$</code> I think you could play around with how <code class='latexWorkaround'>$k$</code> changes before and after <code class='latexWorkaround'>$C$</code> to get something more uniform or weird as you fancy.</p>
<p>Well, this is much nicer: we don't need to know anything about the <code class='latexWorkaround'>$x$</code> value for a mapped zero and it's just one value, some chosen <code class='latexWorkaround'>$k$</code>.</p>
<p>Now that we at least have a general method of talking about being close to an intersection.
(My god, We're only on the second line of iq's derivation…)
What should the curve be in that interval?
I'm not sure there's an intelligent reason for choosing linear interpolation over something more exotic looking besides
that linear interpolation is familiar and more importantly meets our first constraint for our constructed curve/ spline thingy,
namely it must be <code class='latexWorkaround'>$f$</code> at the beginning of "being close to the intersection” (<code class='latexWorkaround'>$i.e$</code> at <code class='latexWorkaround'>$d = -k$</code>) and
<code class='latexWorkaround'>$g$</code> at the end of "being close to the intersection” (<code class='latexWorkaround'>$i.e$</code> at <code class='latexWorkaround'>$d = k$</code>).</p>
<p>Linear interpolation: <br>
<code class='latexWorkaround'>$ξ = (1 - u)f + ug$</code>&nbsp;; &nbsp;<code class='latexWorkaround'>$u ∈ [0, 1]$</code> <br>
So when <code class='latexWorkaround'>$u = 0, ξ = f$</code> and <code class='latexWorkaround'>$u = 0, ξ = g$</code></p>
<p>But we're not necessarily working on the interval <code class='latexWorkaround'>$[0, 1]$</code>
Thus we have to map our chosen "closeness" interval <code class='latexWorkaround'>$[-k, k]$</code> to <code class='latexWorkaround'>$[0, 1]$</code></p>
<p>Like the choice of linear interpolation, linear mapping seems easiest/ most familar:</p>
<p><code class='latexWorkaround'>$ℓ = mx + b$</code> <br>
With boundary conditions:
<code class='latexWorkaround'>$ℓ(-k) = 0$</code> and <code class='latexWorkaround'>$ℓ(k) = 1$</code><br>
<code class='latexWorkaround'>$ℓ(-k) = -mk + b = 0, \implies b = mk$</code><br>
<code class='latexWorkaround'>$ℓ(k) = mk + mk = 2mk = 1 \implies m = \frac{1}{2k}$</code> <br>
<code class='latexWorkaround'>$\implies b = \frac{1}{2}$</code><br>
<code class='latexWorkaround'>$\implies ℓ = \frac{x}{2k} + \frac{1}{2}$</code></p>
<p>but we're interpolating over the difference, not <code class='latexWorkaround'>$x$</code></p>
<p><code class='latexWorkaround'>$ℓ = \frac{d}{2k} + \frac{1}{2}$</code></p>
<p>also, we don't want to include values outside the "sufficiently close" interval
<code class='latexWorkaround'>$\implies$</code> we don't want to include the values when <code class='latexWorkaround'>$ℓ &lt; 0$</code> and <code class='latexWorkaround'>$ℓ &gt; 1$</code></p>
<p><code class='latexWorkaround'>$\implies ℓ =$</code> max(0, min(<code class='latexWorkaround'>$1$</code>,  <code class='latexWorkaround'>$ℓ$</code>), note that this is the same as the glsl hardware accelerated function <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/clamp.xhtml">clamp</a>;</p>
<p>in glsl: <code class='latexWorkaround'>$ℓ =$</code> clamp(<code class='latexWorkaround'>$ℓ$</code>, <code class='latexWorkaround'>$0$</code>, <code class='latexWorkaround'>$1$</code>)</p>
<p>Just using a linear interpolation between our functions with the correctly mapped interval gives us a pretty good result:
<code class='latexWorkaround'>$ξ = (1-ℓ)f + ℓg$</code>;
<code class='latexWorkaround'>$ℓ = d / {2k} + 1/2$</code> and <code class='latexWorkaround'>$k ≈ 0.1$</code></p>
<div id="center">
    <img src="../../images/polynomialSmin/firstApproxNaive.png">
    <p>As expected, our interpolated curve is equal to <code class='latexWorkaround'>$f$</code> and <code class='latexWorkaround'>$g$</code> when <code class='latexWorkaround'>$d = -k$</code> and <code class='latexWorkaround'>$d = k$</code> respectively.</p>
</div>
<div id="center">
    <img src="../../images/polynomialSmin/firstApproxWithClamp.png">
    <p>This is improved by limiting our ℓ value to only ever be between <code class='latexWorkaround'>$0$</code> and <code class='latexWorkaround'>$1$</code> as reasoned before</p>
</div>
<p>What now and how do we improve on this? Well, before we go racking our brains for something more creative, what other constraints exist for our curve?<br>
Not only must ξ evaluate to <code class='latexWorkaround'>$f$</code> &amp; <code class='latexWorkaround'>$g$</code> at the "closeness" interval boundaries, but since it's supposed to be smooth,
its derivative must also match the boundaries' derivatives.<br>
So what is ξ's derivative?</p>
<p><code class='latexWorkaround'>$ξ = (1-ℓ)f + ℓg$</code></p>
<p>by the product rule:</p>
<p><code class='latexWorkaround'>$\frac{dξ}{dx} = \frac{d(1-ℓ)}{dx}f + \frac{df}{dx}(1-ℓ) + \frac{dℓ}{dx}g + \frac{dg}{dx}ℓ$</code></p>
<p><code class='latexWorkaround'>$\frac{dξ}{dx} = \frac{-dℓ)}{dx}f + \frac{df}{dx} - ℓ\frac{df}{dx} + \frac{dℓ}{dx}g + \frac{dg}{dx}ℓ$</code></p>
<p>collecting like terms:</p>
<p><code class='latexWorkaround'>$\frac{dξ}{dx} = (g - f)\frac{dℓ)}{dx} + (1 - ℓ)\frac{df}{dx} + \frac{dg}{dx}ℓ$</code></p>
<p>Note that <code class='latexWorkaround'>$g - f$</code> is just <code class='latexWorkaround'>$-d$</code></p>
<p>Testing our first boundary: <code class='latexWorkaround'>$d = -k \implies l = 0,  g - f = k$</code></p>
<p>Again <code class='latexWorkaround'>$ξ = (1-ℓ)f + ℓg, l = 0 \implies g = 0$</code></p>
<p><code class='latexWorkaround'>$\frac{dξ}{dx} = k\frac{dℓ)}{dx} + \frac{df}{dx}$</code></p>
<p>We require ξ's derivative to equal the derivative of <code class='latexWorkaround'>$f$</code> at this boundary in order to be smooth. <br></p>
<p>Thus we must subtract this extra, first term from our original expression for ξ's derivative to match.</p>
<p><code class='latexWorkaround'>$\implies \frac{dξ}{dx} = (g - f)\frac{dℓ)}{dx} + (1 - ℓ)\frac{df}{dx} + \frac{dg}{dx}ℓ - k\frac{dℓ)}{dx}$</code></p>
<p>Similarly, evaluating ξ's derivative at the other boundary:</p>
<p><code class='latexWorkaround'>$d = k \implies l = 1,  g - f = -k$</code>
<code class='latexWorkaround'>$\implies \frac{dξ}{dx} = (-k)\frac{dℓ)}{dx} + (0)\frac{df}{dx} + \frac{dg}{dx}ℓ - k\frac{dℓ)}{dx}$</code>
<code class='latexWorkaround'>$\implies \frac{dξ}{dx} = (-2k)\frac{dℓ)}{dx} + \frac{dg}{dx}ℓ$</code></p>
<p>Again we require ξ's derivative to equal the derivative of <code class='latexWorkaround'>$f$</code> at this boundary for smoothness.</p>
<p>So we must now add this extra term to our expression for ξ's derivative to match</p>
<p><code class='latexWorkaround'>$\implies \frac{dξ}{dx} = (g - f)\frac{dℓ)}{dx} + (1 - ℓ)\frac{df}{dx} + \frac{dg}{dx}ℓ - k\frac{dℓ)}{dx} +2k\frac{dℓ)}{dx}$</code></p>
<p>But now we're a bit stuck… after all, doesn't adding this term change what the ξ's derivative will evaluate to at the first boundary? <br>
Definitely, and if we were to go back and redo our process we'd be stuck in a vicious cirlce; so we need to have this second boundary corrective term disappear at the first boundary, but still be around at the second boundary.</p>
<p>We're in luck though; just such a term exists and has already been used by us, namely, ℓ.<br>
<code class='latexWorkaround'>$ℓ$</code> by design is just such a term, so if we multiply this corrective term by ℓ, it will do precisely what we want it to.</p>
<p><code class='latexWorkaround'>$\implies \frac{dξ}{dx} = (g - f)\frac{dℓ)}{dx} + (1 - ℓ)\frac{df}{dx} + \frac{dg}{dx}ℓ - k\frac{dℓ)}{dx} +2kℓ\frac{dℓ)}{dx}$</code></p>
<p>Whew, that already feels like clever enough work to stop, but we want the function, not its derivative.<br>
So how to integrate this thing?</p>
<p><code class='latexWorkaround'>$ξ = \int_{}^{} (g - f)\frac{dℓ)}{dx} + (1 - ℓ)\frac{df}{dx} + \frac{dg}{dx}ℓ - k\frac{dℓ)}{dx} +2kℓ\frac{dℓ)}{dx} dx$</code></p>
<p>Regrouping terms to make the underlying product rule more obvious.</p>
<p><code class='latexWorkaround'>$ξ = \int_{}^{} g\frac{dℓ)}{dx} - f\frac{dℓ)}{dx} + \frac{df}{dx} - ℓ\frac{df}{dx} + \frac{dg}{dx}ℓ - k\frac{dℓ)}{dx} +2kℓ\frac{dℓ)}{dx} dx$</code></p>
<p><code class='latexWorkaround'>$ξ = \int_{}^{} g\frac{dℓ)}{dx} + \frac{dg}{dx}ℓ - \left(f\frac{dℓ)}{dx} + ℓ\frac{df}{dx}\right) + \frac{df}{dx} - k\frac{dℓ)}{dx} +2kℓ\frac{dℓ)}{dx} dx$</code></p>
<p>reversing the product rule on the first two terms or integrating by parts and integrating the last three, straightforward integrals</p>
<p><code class='latexWorkaround'>$ξ = gℓ - fℓ + f - kℓ + kℓ^2$</code></p>
<p><code class='latexWorkaround'>$\implies ξ = (1 - ℓ)f + ℓg - kℓ(1 - ℓ)$</code></p>
<p>This is exactly iq's function (<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml">mix</a> is glsl hardware accelerated linear interpolation)</p>
<pre><code class="C language-C">// polynomial smooth min (k = 0.1);
float smin( float a, float b, float k )
{
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    return mix( b, a, h ) - k*h*(1.0-h);    
}
</code></pre>
<div id="center">
    <img src="../../images/polynomialSmin/sminFinal.png">
    <p>Our smooth minimum</p>
</div>
<p>Wrapping Up:</p>
<p>This was a little dive into shader flavored spline interpolation; we took a nice result from an authoritative source and rederived it from first principles.
The function itself, as said by iq, is only <code class='latexWorkaround'>$C^1$</code> continous, but we could extend this with our same approach to be whatever order continuous we like at the expense of performance.
Shaders are performance sensitive and the first order polynomial smin is what you mostly see perusing shadertoy.</p>
<p>Live shader can be found <a href="../../demos/sminLive.html">here.</a></p>
<p>If you're curious how I made this shader, the big picture is that I'm using the "over operator" to make a graph of functions which is a really common technique, see <a href="https://thebookofshaders.com/05/">this well known resource </a> for more on that.
Additionally, I am using a handmade easing function that is interpolating over the functions' derivatives' values to make the lines more uniform  with some functional conditionals to help out.<br></p>
<p>Shader code can be found <a href="https://github.com/Stranathan/glslFun/blob/master/sminArticle.glsl"> here </a></p>
<p>Hopefully it's helped someone besides me. Thank you for reading.</p>
      </div>
      
      <div id="categories">
      </div>
      
    </div>
  
  </body>
<html>

