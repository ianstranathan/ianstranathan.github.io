<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="../../misc/miscImgs/hello.ico">
    <title>Ian Stranathan</title>
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <!-- CSS -->
    <link rel="stylesheet" href="../../style/style.css">
    
    <!-- Katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
              // customised options
              // • auto-render specific keys, e.g.:
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              // • rendering keys, e.g.:
              throwOnError : false
            });
        });
    </script>
    <!-- highlightjs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script defer>hljs.highlightAll();</script>
    <!-- Google Font -->  
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cousine&display=swap" rel="stylesheet"> 
    <!-- FontAwesome -->
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- My own stuff -->
    <!-- ---------------------------------------------------------------  -->
    <script src="../../scripts/metaStuff.js"></script>
    <script src="../../scripts/header.js" defer></script>
    <script src="../../scripts/about.js" defer></script>
    <!-- Injects table of contents at beginning of each content div -->
    <script src="../../scripts/makeTableOfContents.js" defer></script>
    <!-- Injects page with static pages from metadata -->
    <script src="../../scripts/linkInjection.js" defer></script>
    <script src="../../scripts/latexWorkAround.js" defer></script>
    <script src="../../scripts/footer.js" defer></script>
  
    <!-- ---------------------------------------------------------------  -->
  </head>

  <body>
   
    <div id="header">
    </div>
    
    <div id="content-categories-container">
      
      <div id="content"><p><em>It wasn't obvious to me at first blush how the halfway vector took the expression that it did and I couldn't find a clear derivation anywhere
(Not explained on wikipedia, Peter Shirley's Fundamentals of Computer Graphics (4th edition), or Real Time Rendering (3rd edition), clearly too trivial for the wizard beards.</em></p>
<h1 id="whymotivation">Why?/Motivation:</h1>
<p>Historically in graphics, various interpolation lighting models were used to
 produce continuous shading of surfaces represented by data associated with polygonal meshes.</p>
<p>By lighting model I mean a simplified, non-conserving, bidirectional reflectance model (really a smart hueristic) that just uses
 the vertex's normal, a light and viewing direction.</p>
<p>Each traditional shading model is named after its inventor.</p>
<p>If the data  of each vertex, the corners of each triangle, are interpolated (vertex to vertex, done in a vertex shader) then it's said to be Gouraud shading.
If the pixel values between vertices are interpolated (pixel to pixel, done in a fragment shader) then it's said to be Phong shading.</p>
<!-- ![Gouraud versus Phong shading, from wikipedia](../..images/halfwayVector/PhongVersusGouraud.jpg) -->
<div id="center">
    <img src="../../images/halfwayVector/PhongVersusGouraud.jpg">
    <p>Gouraud versus Phong shading, from wikipedia</p>
</div>
<p>This is accomplished by the internal interpolation that happens in a "varying"/ "in"/ "SV_POSITION" variables associated with this vertex.</p>
<p>So for example, a vertex normal would have a continuous smearing of normals, fragment to fragment. 
This can then be normalized and dotted with the viewing direction to find a diffuse shading weight.</p>
<!-- ![Diagram from [learnwebgl.brown37.net](http://learnwebgl.brown37.net/09_lights/lights_diffuse.html)](../images/halfwayVector/learnWebGL.png) -->
<div id="center">
    <img src="../../images/halfwayVector/learnWebGL.png">
    <p>Diagram from <a href="http://learnwebgl.brown37.net/09_lights/lights_diffuse.html">learnwebgl.brown37.net</a></p>
</div>
<p>An associated reflection vector can be found as described in <a href="reflectionAndRefractionInARaytracer.md.html">Reflection and Refraction in a Raytracer</a> for approximated specular lighting.
There are also hardware accelerated functions in modern shading languages for finding the reflection vector, e.g. reflect() in glsl.</p>
<p>This works well for diffuse lighting as the dot product between the normal and viewing vectors will
only be ever deal with angles of 90 degrees / <code class='latexWorkaround'>$\frac{\pi}{2}$</code> or less, but this is not the case for the reflection vector.</p>
<!-- ![Diagram from [learnOpenGL.com](https://learnopengl.com/Advanced-Lighting/Advanced-Lighting)](../images/halfwayVector/learnOpenGL.png) -->
<div id="center">
    <img src="../../images/halfwayVector/learnOpenGL.png">
    <p>Diagram from <a href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">learnOpenGL.com</a></p>
</div>
<p>This is why the "halfway vector" was introduced by Jim Blinn in the Blinn-Phong lighting model.</p>
<p>Mathematically, the halfway vector is nothing more than an angle bisector vector with normalized components, but really it's a <b><em>mapping</em></b> of how oblique/ aligned with the reflection vector the viewing angle is to the angle between
it and the normal, thus recovering a better approximation/ hueristic for specular lighting.</p>
<!-- ![Diagram from [learnOpenGL.com](https://learnopengl.com/Advanced-Lighting/Advanced-Lighting)](../images/halfwayVector/learnOpenGL2.png) -->
<div id="center">
    <img src="../../images/halfwayVector/learnOpenGL2.png">
    <p>Diagram from <a href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">learnOpenGL.com</a></p>
</div>
<h1 id="derivation">Derivation</h1>
<p>For two vectors (light direction and and viewing vector) <code class='latexWorkaround'>$\vec l$</code> &amp; <code class='latexWorkaround'>$\vec v$</code>
the bisecting vector between them is: <code class='latexWorkaround'>$\lvert \vec v \rvert \vec l + \lvert \vec l \rvert \vec v$</code></p>
<p>See the article for <a href="../Math/angleBisector.html">angle bisector vector</a> for a derivation of this expression.</p>
<p>If both vectors have both been normalized then this reduces to:
<code class='latexWorkaround'>$\vec v + \vec l$</code></p>
<p>The halfway vector as presented in literature is just the unit version of this vector:</p>
<p><code class='latexWorkaround'>$\vec H = \frac{\vec v + \vec l}{\lvert \vec v + \vec l \rvert}$</code></p>
      </div>
      
      <div id="categories">
      </div>
      
    </div>
  
  </body>
<html>

