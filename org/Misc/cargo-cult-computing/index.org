You'll be a real programmer if you:

- only use keyboard based text editors and a shell, no IDEs

- use mechanical keyboards of the hand soldered, ergonomically split, non-traditial/ optimized key layout variety

- become a rabid fan of whatever language or ecosystem you fall into and defend them, no matter how dysfunctional.

- only use the lowest level langauge you can, it's more powerful/ faster (compiled, statically typed, manual memory management)

- only use the highest level language you can, it's more productive/ expressive (dynamically typed, GC , compiled or interpreted)

- only use standard library data structures and well established libraries, don't reinvent the wheel/ use good black boxes.

- roll all your own tools and libraries, you can't always trust a black box.

- use OOP, RAII / ARC,  design patterns, embrace the standard, clean code and terrible performance

- use FP and hate OOP, state complexity is the root of all evil and parallelism is free.

- use CPU architecture oriented/ cache friendly imperative programming and hate everything

*Discrete tools in a continuous problem space*

#+BEGIN_COMMENT
Often dev time, correctness, I/O time, scriptability, real-time changeability, are more important than CPU time, sometimes
#+END_COMMENT

#+BEGIN_QUOTE
Vīta brevis,
ars longa,
occāsiō praeceps,
experīmentum perīculōsum,
iūdicium difficile.
#+END_QUOTE


