
#+TITLE: Halfway Vector
#+DATE: <2022-11-01 Tue>
#+FILETAGS: :Graphics:

/It wasn't obvious to me at first blush how the halfway vector took the expression that it did and
I couldn't find a clear derivation anywhere
(Not explained on wikipedia, Peter Shirley's Fundamentals of Computer Graphics (4th edition), or Real Time Rendering (3rd edition),
clearly too trivial for the wizard beards./

* Motivation (Why this?)
  --------------------------------------------------------------------------------------------------------------------------

  Historically in graphics, various interpolation lighting models were used to
  produce continuous shading of surfaces represented by data associated with polygonal meshes.

  By lighting model I mean a simplified, non-conserving, "bidirectional reflectance model" (really a smart hueristic) that just uses
  the vertex's normal, a light and viewing direction.

  Each traditional shading model is named after its inventor.

  If the data  of each vertex, the corners of each triangle, are interpolated (vertex to vertex, done in a vertex shader) then it's said to be *_Gouraud_* shading.
  If the pixel values between vertices are interpolated (pixel to pixel, done in a fragment shader) then it's said to be *_Phong_* shading.


  #+CAPTION: Gouraud versus Phong shading, from wikipedia
  #+NAME:    fig: Gouraud_Versus_Phong
  [[../../../img/Graphics/halfway_vector//PhongVersusGouraud.jpg]]


  This is accomplished by the internal interpolation that happens in a "varying"/ "in"/ "SV_POSITION" variables associated with this vertex.

  This gives a discrete vertex normal that was piped in from the vertex shader a continuous smearing of normals, "fragment" to "fragment", in a fragment shader. [fn:: Fragment is a loaded word and concisely said is just what is ultimately not culled or discarded by a number of pipeline processes outside the scope of this blog post]. 

  #+CAPTION: Interpolated intermediate vertex normals (diagram from [[http://learnwebgl.brown37.net/10_surface_properties/smooth_vertex_normals.html][learnwebgl.brown37.net]])
  #+NAME:    fig: Interpolated_Intermediated_Vertex_Normals
  [[../../../img/Graphics/halfway_vector/intermediate_normal_vectors.png]]

  This can then be normalized and dotted with the viewing direction to find a diffuse shading weight.

  #+CAPTION: Diffuse Lighting Heuristic Diagram (diagram from [[http://learnwebgl.brown37.net/09_lights/lights_diffuse.html][learnwebgl.brown37.net]])
  #+NAME:    fig: Diffuse_Light_Diagram
  [[../../../img/Graphics/halfway_vector/learnWebGL.png]]

  An associated reflection vector can be found as described in
  # [Reflection and Refraction in a Raytracer](reflectionAndRefractionInARaytracer.md.html) for approximated specular lighting.
  There are also hardware accelerated functions in modern shading languages for finding the reflection vector, e.g. reflect() in glsl.

  This works well for diffuse lighting as the dot product between the normal and viewing vectors will
  only be ever deal with angles of 90 degrees / $\frac{\pi}{2}$ or less, but this is not the case for the reflection vector.

  #+CAPTION: The reflection vector can fail (diagram from [[https://learnopengl.com/Advanced-Lighting/Advanced-Lighting][learnOpenGL.com]])
  #+NAME:    fig: Reflection_Vector_Can_Fail
  [[../../../img/Graphics/halfway_vector/learnOpenGL.png]]

  This is why the "halfway vector" was introduced by Jim Blinn as an extension of the Phong Model -> Blinn-Phong lighting model.

  Mathematically, the halfway vector is nothing more than an angle bisector vector with normalized components, but really it's a */mapping/* of
  how oblique or aligned with the reflection vector the viewing angle is to the normal, thus recovering a better approximation/ hueristic for specular lighting.

  #+CAPTION: The Halfway Vector (diagram from [[https://learnopengl.com/Advanced-Lighting/Advanced-Lighting][learnOpenGL.com]])
  #+NAME:    fig: The_Halfway_Vector
  [[../../../img/Graphics/halfway_vector/learnOpenGL2.png]]

* Derivation
  -------------------------------------------------------------------------------

  For two vectors (light direction and and viewing vector) $\vec l$ & $\vec v$
  the bisecting vector between them is: $\lvert \vec v \rvert \vec l + \lvert \vec l \rvert \vec v$

  See the article for [[file:../../Math/angle_bisector/index.org][Vector angle bisector]] for a derivation of this expression.

  If both vectors have both been normalized then this reduces to:
  $\vec v + \vec l$

  The halfway vector as presented in literature is just the unit version of this vector:

  $$\vec H = \frac{\vec v + \vec l}{\lvert \vec v + \vec l \rvert}$$
